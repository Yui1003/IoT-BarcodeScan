/*
 * ESP-IDF v5.3.1
 * USB HID Host Barcode Scanner with WiFi & Firebase
 * File: hid_host_firebase.c
 */

#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <time.h>

#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/queue.h"
#include "freertos/event_groups.h"

#include "esp_log.h"
#include "esp_err.h"
#include "esp_wifi.h"
#include "esp_event.h"
#include "esp_http_client.h"
#include "esp_crt_bundle.h"
#include "nvs_flash.h"

#include "usb/usb_host.h"
#include "usb/hid_host.h"
#include "usb/hid_usage_keyboard.h"

/* ================= CONFIG ================= */

// WiFi Configuration
#define WIFI_SSID      "Del Rosario Family"
#define WIFI_PASSWORD  "Shinzou13579"
#define WIFI_MAXIMUM_RETRY  5

// Firebase Configuration
#define FIREBASE_URL   "https://esp32-barcode-test-default-rtdb.firebaseio.com"
#define FIREBASE_AUTH  "v8AOek9RZPj3qtvhyW3ri7WNVOIZMh78sIpPdghD"

// Barcode Settings
#define BARCODE_MAX_LEN 64
#define APP_QUIT_PIN GPIO_NUM_0

static const char *TAG = "HID_BARCODE";

/* ================= WIFI EVENT GROUP ================= */

static EventGroupHandle_t s_wifi_event_group;
#define WIFI_CONNECTED_BIT BIT0
#define WIFI_FAIL_BIT      BIT1

static int s_retry_num = 0;

/* ================= BARCODE BUFFER & SYNC ================= */

static char barcode_buf[BARCODE_MAX_LEN];
static int barcode_len = 0;

// Buffer for Firebase upload (separate from scanning buffer)
static char firebase_barcode[BARCODE_MAX_LEN];
static SemaphoreHandle_t firebase_semaphore = NULL;

/* ================= WIFI EVENT HANDLER ================= */

static void wifi_event_handler(void* arg, esp_event_base_t event_base,
                               int32_t event_id, void* event_data)
{
    if (event_base == WIFI_EVENT && event_id == WIFI_EVENT_STA_START) {
        esp_wifi_connect();
    } else if (event_base == WIFI_EVENT && event_id == WIFI_EVENT_STA_DISCONNECTED) {
        if (s_retry_num < WIFI_MAXIMUM_RETRY) {
            esp_wifi_connect();
            s_retry_num++;
            ESP_LOGI(TAG, "Retrying to connect to WiFi... (%d/%d)", s_retry_num, WIFI_MAXIMUM_RETRY);
        } else {
            xEventGroupSetBits(s_wifi_event_group, WIFI_FAIL_BIT);
            ESP_LOGE(TAG, "Failed to connect to WiFi");
        }
    } else if (event_base == IP_EVENT && event_id == IP_EVENT_STA_GOT_IP) {
        ip_event_got_ip_t* event = (ip_event_got_ip_t*) event_data;
        ESP_LOGI(TAG, "Connected! IP: " IPSTR, IP2STR(&event->ip_info.ip));
        s_retry_num = 0;
        xEventGroupSetBits(s_wifi_event_group, WIFI_CONNECTED_BIT);
    }
}

/* ================= WIFI INIT ================= */

static void wifi_init_sta(void)
{
    s_wifi_event_group = xEventGroupCreate();

    ESP_ERROR_CHECK(esp_netif_init());
    ESP_ERROR_CHECK(esp_event_loop_create_default());
    esp_netif_create_default_wifi_sta();

    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
    ESP_ERROR_CHECK(esp_wifi_init(&cfg));

    esp_event_handler_instance_t instance_any_id;
    esp_event_handler_instance_t instance_got_ip;
    ESP_ERROR_CHECK(esp_event_handler_instance_register(WIFI_EVENT,
                                                        ESP_EVENT_ANY_ID,
                                                        &wifi_event_handler,
                                                        NULL,
                                                        &instance_any_id));
    ESP_ERROR_CHECK(esp_event_handler_instance_register(IP_EVENT,
                                                        IP_EVENT_STA_GOT_IP,
                                                        &wifi_event_handler,
                                                        NULL,
                                                        &instance_got_ip));

    wifi_config_t wifi_config = {
        .sta = {
            .ssid = WIFI_SSID,
            .password = WIFI_PASSWORD,
            .threshold.authmode = WIFI_AUTH_WPA2_PSK,
        },
    };
    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));
    ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_STA, &wifi_config));
    ESP_ERROR_CHECK(esp_wifi_start());

    ESP_LOGI(TAG, "Connecting to WiFi...");

    EventBits_t bits = xEventGroupWaitBits(s_wifi_event_group,
            WIFI_CONNECTED_BIT | WIFI_FAIL_BIT,
            pdFALSE,
            pdFALSE,
            portMAX_DELAY);

    if (bits & WIFI_CONNECTED_BIT) {
        ESP_LOGI(TAG, "WiFi connected successfully");
    } else if (bits & WIFI_FAIL_BIT) {
        ESP_LOGE(TAG, "WiFi connection failed");
    }
}

/* ================= FIREBASE POST ================= */

static esp_err_t send_to_firebase(const char *barcode)
{
    // Check WiFi connection
    EventBits_t bits = xEventGroupGetBits(s_wifi_event_group);
    if (!(bits & WIFI_CONNECTED_BIT)) {
        ESP_LOGE(TAG, "WiFi not connected, cannot send to Firebase");
        return ESP_FAIL;
    }

    // Get current timestamp
    time_t now;
    time(&now);
    
    // Build Firebase URL: /scanned_items.json?auth=TOKEN
    char url[256];
    snprintf(url, sizeof(url), "%s/scanned_items.json?auth=%s", 
             FIREBASE_URL, FIREBASE_AUTH);

    // Build JSON payload
    char post_data[256];
    snprintf(post_data, sizeof(post_data), 
             "{\"barcode\":\"%s\",\"timestamp\":%ld}", 
             barcode, (long)now);

    ESP_LOGI(TAG, "Sending to Firebase: %s", post_data);
    ESP_LOGI(TAG, "Firebase URL: %s", FIREBASE_URL);

    // Configure HTTP client with certificate bundle for proper SSL/TLS
    esp_http_client_config_t config = {
        .url = url,
        .method = HTTP_METHOD_POST,
        .timeout_ms = 10000,
        .crt_bundle_attach = esp_crt_bundle_attach,
        .transport_type = HTTP_TRANSPORT_OVER_SSL,
        .buffer_size = 2048,
        .buffer_size_tx = 2048,
    };

    esp_http_client_handle_t client = esp_http_client_init(&config);
    
    if (client == NULL) {
        ESP_LOGE(TAG, "Failed to initialize HTTP client");
        return ESP_FAIL;
    }
    
    // Set headers
    esp_http_client_set_header(client, "Content-Type", "application/json");
    esp_http_client_set_post_field(client, post_data, strlen(post_data));

    // Perform HTTP request
    esp_err_t err = esp_http_client_perform(client);

    if (err == ESP_OK) {
        int status_code = esp_http_client_get_status_code(client);
        int content_length = esp_http_client_get_content_length(client);
        
        ESP_LOGI(TAG, "Firebase POST Status = %d, Content-Length = %d", 
                 status_code, content_length);
        
        if (status_code == 200) {
            ESP_LOGI(TAG, "âœ“ Successfully sent to Firebase!");
        } else {
            ESP_LOGE(TAG, "Firebase returned error status: %d", status_code);
            err = ESP_FAIL;
        }
    } else {
        ESP_LOGE(TAG, "Firebase POST failed: %s", esp_err_to_name(err));
    }

    esp_http_client_cleanup(client);
    return err;
}

/* ================= FIREBASE TASK ================= */

static void firebase_task(void *arg)
{
    ESP_LOGI(TAG, "Firebase task started");
    
    while (1) {
        // Wait for semaphore signal (barcode ready)
        if (xSemaphoreTake(firebase_semaphore, portMAX_DELAY) == pdTRUE) {
            ESP_LOGI(TAG, "Processing barcode: %s", firebase_barcode);
            
            // Send to Firebase (this runs in background, won't block USB)
            esp_err_t err = send_to_firebase(firebase_barcode);
            
            if (err != ESP_OK) {
                ESP_LOGW(TAG, "âš  Failed to send to Firebase");
            }
            
            // Clear the buffer
            memset(firebase_barcode, 0, sizeof(firebase_barcode));
            
            // Small delay between requests
            vTaskDelay(pdMS_TO_TICKS(100));
        }
    }
}

/* ================= KEYCODE â†’ ASCII ================= */

static char keycode_to_ascii(uint8_t keycode)
{
    if (keycode >= HID_KEY_A && keycode <= HID_KEY_Z) {
        return 'a' + (keycode - HID_KEY_A);
    }
    if (keycode >= HID_KEY_1 && keycode <= HID_KEY_9) {
        return '1' + (keycode - HID_KEY_1);
    }
    if (keycode == HID_KEY_0) return '0';
    if (keycode == HID_KEY_MINUS) return '-';
    if (keycode == HID_KEY_ENTER) return '\n';
    return 0;
}

/* ================= KEYBOARD REPORT ================= */

static void handle_keyboard_report(const uint8_t *data, int length)
{
    if (length < 8) return;

    uint8_t keycode = data[2];
    char c = keycode_to_ascii(keycode);

    if (!c) return;

    if (c == '\n') {
        barcode_buf[barcode_len] = '\0';

        if (barcode_len > 0) {
            ESP_LOGI(TAG, "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
            ESP_LOGI(TAG, "ğŸ“¦ Scanned barcode: %s", barcode_buf);
            ESP_LOGI(TAG, "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
            
            // Copy to Firebase buffer and signal the task
            strncpy(firebase_barcode, barcode_buf, BARCODE_MAX_LEN - 1);
            firebase_barcode[BARCODE_MAX_LEN - 1] = '\0';
            
            // Signal Firebase task (non-blocking)
            xSemaphoreGive(firebase_semaphore);
        }

        barcode_len = 0;
        memset(barcode_buf, 0, sizeof(barcode_buf));
        return;
    }

    if (barcode_len < BARCODE_MAX_LEN - 1) {
        barcode_buf[barcode_len++] = c;
    }
}

/* ================= HID INTERFACE CALLBACK ================= */

static void hid_interface_callback(
    hid_host_device_handle_t hid_device_handle,
    hid_host_interface_event_t event,
    void *arg)
{
    if (event != HID_HOST_INTERFACE_EVENT_INPUT_REPORT) return;

    uint8_t data[64];
    size_t data_len = sizeof(data);

    ESP_ERROR_CHECK(
        hid_host_device_get_raw_input_report_data(
            hid_device_handle,
            data,
            64,
            &data_len
        )
    );

    handle_keyboard_report(data, data_len);
}

/* ================= HID DEVICE EVENT ================= */

static void hid_device_event(
    hid_host_device_handle_t hid_device_handle,
    hid_host_driver_event_t event,
    void *arg)
{
    if (event == HID_HOST_DRIVER_EVENT_CONNECTED) {

        hid_host_dev_params_t params;
        hid_host_device_get_params(hid_device_handle, &params);

        ESP_LOGI(TAG, "HID device connected (%s)",
                 params.proto == HID_PROTOCOL_KEYBOARD ? "Keyboard" : "Other");

        const hid_host_device_config_t dev_cfg = {
            .callback = hid_interface_callback,
            .callback_arg = NULL
        };

        ESP_ERROR_CHECK(hid_host_device_open(hid_device_handle, &dev_cfg));

        if (params.sub_class == HID_SUBCLASS_BOOT_INTERFACE &&
            params.proto == HID_PROTOCOL_KEYBOARD) {
            hid_class_request_set_protocol(hid_device_handle,
                                           HID_REPORT_PROTOCOL_BOOT);
            hid_class_request_set_idle(hid_device_handle, 0, 0);
        }

        hid_host_device_start(hid_device_handle);
    }
}

/* ================= USB HOST TASK ================= */

static void usb_host_task(void *arg)
{
    usb_host_config_t host_cfg = {
        .skip_phy_setup = false,
        .intr_flags = ESP_INTR_FLAG_LEVEL1
    };

    ESP_ERROR_CHECK(usb_host_install(&host_cfg));

    hid_host_driver_config_t hid_cfg = {
        .create_background_task = true,
        .task_priority = 5,
        .stack_size = 4096,
        .core_id = 0,
        .callback = hid_device_event,
        .callback_arg = NULL
    };

    ESP_ERROR_CHECK(hid_host_install(&hid_cfg));

    ESP_LOGI(TAG, "USB HID Host ready");

    while (1) {
        uint32_t events;
        usb_host_lib_handle_events(portMAX_DELAY, &events);
    }
}

/* ================= APP MAIN ================= */

void app_main(void)
{
    ESP_LOGI(TAG, "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
    ESP_LOGI(TAG, "  Inventory Management System");
    ESP_LOGI(TAG, "  Barcode Scanner â†’ Firebase");
    ESP_LOGI(TAG, "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");

    // Initialize NVS (required for WiFi)
    esp_err_t ret = nvs_flash_init();
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
        ESP_ERROR_CHECK(nvs_flash_erase());
        ret = nvs_flash_init();
    }
    ESP_ERROR_CHECK(ret);

    // Create binary semaphore for Firebase signaling
    firebase_semaphore = xSemaphoreCreateBinary();
    if (firebase_semaphore == NULL) {
        ESP_LOGE(TAG, "Failed to create Firebase semaphore");
        return;
    }

    // Initialize WiFi
    wifi_init_sta();

    // Start Firebase task on core 1
    xTaskCreatePinnedToCore(
        firebase_task,
        "firebase_task",
        8192,
        NULL,
        4,
        NULL,
        1
    );

    // Start USB Host Task on core 0
    xTaskCreatePinnedToCore(
        usb_host_task,
        "usb_host_task",
        4096,
        NULL,
        5,
        NULL,
        0
    );

    ESP_LOGI(TAG, "System ready! Waiting for barcode scans...");
}